# 퀵 정렬

left, pivot, right 인덱스를 설정하고, 각각 첫 데이터의 인덱스, 중간 데이터의 값, 마지막 데이터의 인덱스를 가진다.

left 인덱스는 오른쪽으로 이동하고, right 인덱스는 왼쪽으로 이동한다.

그러다가 left 는 pivot 값보다 큰 데이터를 만나면 멈추고, right 는 pivot 보다 작은 데이터를 만나면 멈춘다.

그리고 서로 스왑한다.

이 과정을 각각 반복하다가 left와 right 가 서로 교차되면 피벗값을 기준으로 왼쪽 구역(start부터 left)과 오른쪽 구역(rigth부터 end)에 대해 다시 퀵 정렬을 실행한다.

만약 left와 right 가 교차되지 않았다면(서로 같은 위치거나 right가 left보다 큰 경우) left는 +1을 해주고, right는 -1을 해주어 교차시켜준다.

## 시간 복잡도 
- O(n log n)
- 최악의 경우(피벗값이 최댓값 혹은 최솟값일 경우 O(n<sup>2</sup>)
- 최악의 경우는 Median of Medians 알고리즘을 통해 회피할 수 있으나 오버헤드가 추가된다.